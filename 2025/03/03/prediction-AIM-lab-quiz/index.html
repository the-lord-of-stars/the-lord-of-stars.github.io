
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>AIM Lab CW1 Review | qp blog</title>
    <meta name="author" content="Zefei Xie" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/img.png" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>The loading is slow, please enable the cache.</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>QP BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;QP BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>AIM Lab CW1 Review</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/3
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/academic/" style="color: #00a596">
                    academic
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/review/" style="color: #ff7d73">
                    review
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h2><h3 id="Lab-Code"><a href="#Lab-Code" class="headerlink" title="Lab Code"></a>Lab Code</h3><p>The RandomBitFlipHeuristic:</p>
<pre><code class="language-java">public void applyHeuristic(SAT problem) &#123;
    // Select a random bit to flip
   int randomIndex = random.nextInt(problem.getNumberOfVariables());
   problem.bitFlip(randomIndex, CURRENT_SOLUTION_INDEX);
&#125;
</code></pre>
<h3 id="Lab-Quiz"><a href="#Lab-Quiz" class="headerlink" title="Lab Quiz"></a>Lab Quiz</h3><p>In week1, the lab quiz was just all about the introduction of the api and the basis for the question, the Max-SAT problem concept.</p>
<ol>
<li><p><strong>Max-SAT</strong> is a problem in computer science that involves finding a solution to a boolean satisfiability problem (SAT) by finding a subset of the variables that satisfy all the clauses in the SAT problem. The goal is to find a solution that maximizes the number of satisfied clauses. The Max-SAT problem is NP-complete, meaning that it is not possible to solve in polynomial time for all possible inputs. However, there are many heuristics that can be used to solve the problem efficiently in practice.</p>
<p>ex. (A ∨ ¬B) ∧ (B ∨ C) ∧ (¬A ∨ ¬C)</p>
</li>
<li><p>In the lab, a very important concept of the <strong>Random</strong> was given. That is the value of the random function is not actually random, but is determined by a seed value. This seed value is used to generate a sequence of pseudo-random numbers that can be used for various purposes, such as generating random numbers, selecting random elements from a set, and shuffling a list. The seed value can be set to a fixed value to produce a deterministic sequence of pseudo-random numbers, or it can be set to a random value to produce a different sequence each time the program is run. Therefore, if the seed value is not changed in each trial, it will always give us the same solution.</p>
</li>
</ol>
<h3 id="Question-Quiz"><a href="#Question-Quiz" class="headerlink" title="Question Quiz"></a>Question Quiz</h3><ol>
<li><p><strong>Concept</strong>:</p>
<ul>
<li><strong>Open</strong> decision support system (depend on the environment), <strong>Close</strong> decision support system (independent),</li>
<li><strong>effective</strong> (can find the best solution), efficient (fast).</li>
</ul>
</li>
<li><p><strong>Concept</strong>:</p>
<ul>
<li><strong>Stochastic</strong> searching  method (vary from time to time), <strong>deterministic</strong> searching method (always the same result),</li>
<li><strong>perturbative</strong> searching method (start with a complete solution and gradually change it), <strong>constructive</strong> searching method (start with an partial solution and gradually build it).</li>
</ul>
</li>
<li><p><strong>Concept</strong>: </p>
<p><strong>Exact methods</strong></p>
<ul>
<li>Dynamic programming, Branch and Bound, Constraint Satisfaction </li>
<li>Systematically traverse the search space.</li>
<li>Has optimality guarantees</li>
</ul>
<p><strong>Inexact methods</strong></p>
<ul>
<li>Heuristics&#x2F;Metaheuristics&#x2F;Hyper-heuristics</li>
<li>Sample the search space through neighbourhood operators. </li>
<li>No optimality guarantees.</li>
</ul>
</li>
</ol>
<h2 id="Week-2"><a href="#Week-2" class="headerlink" title="Week 2"></a>Week 2</h2><h3 id="Lab-Code-1"><a href="#Lab-Code-1" class="headerlink" title="Lab Code"></a>Lab Code</h3><p>Steepest Descent Hill Climbing:</p>
<pre><code class="language-java">public void applyHeuristic(SAT problem) &#123;
    double bestEval = problem.getObjectiveFunctionValue(CURRENT_SOLUTION_INDEX);
    int bestIndex = 0;
    boolean improved = false;

    for (int j = 0; j &lt; problem.getNumberOfVariables(); j++) &#123;
        problem.bitFlip(j, CURRENT_SOLUTION_INDEX);
        double eval = problem.getObjectiveFunctionValue(CURRENT_SOLUTION_INDEX);

        if (eval &lt; bestEval) &#123;
            bestIndex = j;
            bestEval = eval;
            improved = true;
        &#125;
        problem.bitFlip(j, CURRENT_SOLUTION_INDEX);
    &#125;

    if (improved) &#123;
        problem.bitFlip(bestIndex, CURRENT_SOLUTION_INDEX);
    &#125;
&#125;
</code></pre>
<p>Davis’s Bit Hill Climbing:</p>
<pre><code class="language-java">public void applyHeuristic(SAT problem) &#123;
    double bestEval = problem.getObjectiveFunctionValue(CURRENT_SOLUTION_INDEX);
    int[] perm = new int[problem.getNumberOfVariables()];

    for (int i = 0; i &lt; problem.getNumberOfVariables(); i++) &#123;
        perm[i] = i;
    &#125;
    perm = ArrayMethods.shuffle(perm, random);

    for (int j = 0; j &lt; problem.getNumberOfVariables(); j++) &#123;
        problem.bitFlip(perm[j], CURRENT_SOLUTION_INDEX);
        double tempEval = problem.getObjectiveFunctionValue(CURRENT_SOLUTION_INDEX);

        if (tempEval &lt;= bestEval) &#123;
            bestEval = tempEval;
        &#125; else &#123;
            problem.bitFlip( perm[j], CURRENT_SOLUTION_INDEX);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Lab-Quiz-1"><a href="#Lab-Quiz-1" class="headerlink" title="Lab Quiz"></a>Lab Quiz</h3><p>In week2, the lab is focusing on Steepest Descent Hill Climbing and Davis’s Bit Hill Climbing.</p>
<ol>
<li><strong>Steepest Descent Hill Climbing</strong> is a local search algorithm that starts with a random solution and only change the most significant bit that decreases the objective function value. It is a simple and effective algorithm that can find a good solution in a short time. However, it may not find the global optimum.</li>
<li><strong>David’s Bit Hill Climbing</strong> is a local search algorithm that will initially create a random permutation of the changing indexes list, and improve the solution gradually.</li>
</ol>
<p>If we change the heuristic to <strong>better or equal than</strong> the current solution:</p>
<p>Correct answers would identify that DBHC performs better accepting non-worsening moves; however, SDHC could perform different based on the acceptance criteria.</p>
<p>For DBHC this includes not getting stuck on shoulder regions, whereas for SDHC this is down to two factors. In one case, we may be able to move over the shoulder regions leading to better performance, but in the other case, preferring to change the latter variable assignments may lead to getting stuck in regions of the search space with poor quality solutions as compared to flipping earlier variable assignments.</p>
<h2 id="Week-3"><a href="#Week-3" class="headerlink" title="Week 3"></a>Week 3</h2><h3 id="Lab-Code-2"><a href="#Lab-Code-2" class="headerlink" title="Lab Code"></a>Lab Code</h3><p>Iterated Local Search:</p>
<pre><code class="language-java">protected void runMainLoop() &#123;
    for (int i = 0; i &lt; iIntensityOfMutation; i++) &#123;
        // apply mutation heuristic
       oMutationHeuristic.applyHeuristic(problem);
    &#125;
    for (int i = 0; i &lt; iDepthOfSearch; i++) &#123;
        oLocalSearchHeuristic.applyHeuristic(problem);
    &#125;
    double backEval = problem.getObjectiveFunctionValue(BACKUP_SOLUTION_INDEX);
    double newEval = problem.getObjectiveFunctionValue(CURRENT_SOLUTION_INDEX);

    if (newEval &lt;= backEval) &#123;
        // accept new solution
       problem.copySolution(CURRENT_SOLUTION_INDEX, BACKUP_SOLUTION_INDEX);
    &#125;else&#123;
        // reject new solution
       problem.copySolution(BACKUP_SOLUTION_INDEX, CURRENT_SOLUTION_INDEX);
    &#125;
&#125;
</code></pre>
<h3 id="Lab-Quiz-2"><a href="#Lab-Quiz-2" class="headerlink" title="Lab Quiz"></a>Lab Quiz</h3><p>In week 3, the lab is focusing on iterated local search.</p>
<ol>
<li><p>Q2: </p>
<p>ILS is only applying hill-climbing and hence has no explorative mechanisms when IOM is set to zero.</p>
<p>“behave” is not like “perform”, behave means the outcomes could be the same, perform is more enphasizing the procedure.</p>
</li>
<li><p>Q4:</p>
<p><strong>tail selection</strong>: you should choose 1 tail when you want to know the direction of the data (&gt; or &lt;)</p>
<p>and you should choose 2 tail if you want to know if there is a difference between 2 set of data.</p>
<p><strong>Test type:</strong></p>
<table>
<thead>
<tr>
<th>Test Name</th>
<th>data</th>
<th>scene</th>
<th>Critera</th>
</tr>
</thead>
<tbody><tr>
<td>T test</td>
<td>independent&#x2F;paired</td>
<td>focus on mean difference</td>
<td>mean</td>
</tr>
<tr>
<td>Wilcoxon SIgned Rank Test</td>
<td>paired</td>
<td>not Gaussian distribution</td>
<td>middle value</td>
</tr>
<tr>
<td>Mann-Whitney U test</td>
<td>independent</td>
<td>not Gaussian distribution</td>
<td>middle value</td>
</tr>
<tr>
<td>Sign Test</td>
<td>paired</td>
<td>focus on direction</td>
<td>middle value</td>
</tr>
</tbody></table>
<p><strong>P value:</strong> when p value is big (usually &gt;&#x3D; 0.05) then we can not disagree the h0: the 2 data sets are identical. only when p value is &lt; than 0.05 then we can use the relevant critera to decide which method is better&#x2F; worse. </p>
</li>
<li><p>Q5:<br>The behaviour of ILS with different components can be totally different and hence may require entirely different configurations for IOM and DOS</p>
</li>
<li><p>Q7:</p>
<p>The first is that the combination of SDHC with the 1-bit flip neighbourhood is not ideal as SDHC flipping a single bit that leads to the most improvement can easily undo changes by the mutation operator.</p>
<p>The second point makes a comparison of SDHC and DBHC in terms of their efficiency and effectiveness (see ILS design guidelines from lecture 3). Both hill-climbing heuristics make the same number of function evaluations per pass (take the same computational budget) however DBHC is able in theory to modify [0,n) bits whereas SDHC can only modify [0,1] bits; hence SDHC is less efficient than DBHC.</p>
</li>
</ol>
<h2 id="Week-4"><a href="#Week-4" class="headerlink" title="Week 4"></a>Week 4</h2><h3 id="Lab-Code-3"><a href="#Lab-Code-3" class="headerlink" title="Lab Code"></a>Lab Code</h3><p>Simulated Annealing:</p>
<pre><code class="language-java">protected void runMainLoop() &#123;
    double temperature = oCoolingSchedule.getCurrentTemperature();
    double eval = problem.getObjectiveFunctionValue(CURRENT_SOLUTION_INDEX);

    // Select a random bit to flip
   int randomIndex = random.nextInt(problem.getNumberOfVariables());
   problem.bitFlip(randomIndex, CURRENT_SOLUTION_INDEX);
   double newEval = problem.getObjectiveFunctionValue(CURRENT_SOLUTION_INDEX);
   double delta = newEval - eval;
   double probability = Math.exp(-delta/temperature);

   // If the new solution is better or the probability is higher, accept it
   if (delta &lt; 0 || random.nextDouble() &lt; probability) &#123;
       problem.bitFlip(randomIndex, BACKUP_SOLUTION_INDEX);
   &#125;else &#123;
       problem.bitFlip(randomIndex, CURRENT_SOLUTION_INDEX);
   &#125;

   // Update the temperature
   oCoolingSchedule.advanceTemperature();
&#125;
</code></pre>
<p>Geometric Cooling Schedule:</p>
<pre><code class="language-java">public void advanceTemperature() &#123;
    dCurrentTemperature *= this.dAlpha;
&#125;
</code></pre>
<p>LundyAndMees Cooling Schedule:</p>
<pre><code class="language-java">public void advanceTemperature() &#123;
    dCurrentTemperature =  dCurrentTemperature / ( 1 + dBeta * dCurrentTemperature );
&#125;
</code></pre>
<h3 id="Lab-Quiz-3"><a href="#Lab-Quiz-3" class="headerlink" title="Lab Quiz"></a>Lab Quiz</h3><p>This week lab is relative simple, it is only focusing on the Simulated Annealing: </p>
<ul>
<li>The algorithm is allowed to occasionally accept a poor solution (that is, a solution worse than the current one), thus jumping out of the local optimal.</li>
<li>By decreasing the temperature parameter (T), the probability of accepting the poor solution is reduced, so that the solution gradually converges to the global optimal.</li>
</ul>
<p>The key to solve the quiz is that the alpha for geometric cooling schema should be very close to 1 (ex. 0.99998). If the temperature get cooled so fast then the algorithm will just become the IE algorithm. Similarly, the beta for LundyAndMees Cooling Schema should be very small (ex. 0.00001).</p>
<h2 id="Week-5"><a href="#Week-5" class="headerlink" title="Week 5"></a>Week 5</h2><h3 id="Lab-Code-4"><a href="#Lab-Code-4" class="headerlink" title="Lab Code"></a>Lab Code</h3><p>Memetic Algorithm:</p>
<pre><code class="language-java">public void runMainLoop() &#123;
    for(int iIterationCount = 0; iIterationCount &lt; POPULATION_SIZE; iIterationCount += 2) &#123;
        int iParent1, iParent2;
        iParent1 = p1Selection.parentSelection();
        iParent2 = p2Selection.parentSelection();
        if(iParent1 == iParent2) &#123;
            iParent2 = (iParent1 + 1) % POPULATION_SIZE;
        &#125;
        int iChild1 = POPULATION_SIZE + iIterationCount;
        int iChild2 = POPULATION_SIZE + iIterationCount +1;
        crossover.applyHeuristic(iParent1, iParent2, iChild1, iChild2);
        mutation.applyHeuristic(iChild1);
        localSearch.applyHeuristic(iChild1);
        mutation.applyHeuristic(iChild2);
        localSearch.applyHeuristic(iChild2);
    &#125;
    // not forgetting to do replacement of the population AFTER all offspring are produced
   replacement.doReplacement(problem, POPULATION_SIZE);
&#125;
</code></pre>
<p>Crossover (UniformXO):</p>
<pre><code class="language-java">public void applyHeuristic(int parent1Index, int parent2Index,
			int child1Index, int child2Index) &#123;
    problem.copySolution(parent1Index, child1Index);
    problem.copySolution(parent2Index, child2Index);

    for(int i = 0; i &lt; problem.getNumberOfVariables(); i++) &#123;
        if(random.nextDouble() &lt; 0.5) &#123;
            problem.exchangeBits(child1Index, child2Index, i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>Selection (Tournament Selection):</p>
<pre><code class="language-java">public int parentSelection() &#123;
	int bestIndex = -1;
	double bestFitness = Double.MAX_VALUE;

	//create list of random indices
	int[] indices = ArrayMethods.shuffle(aiParentIndices, oRandom);

	// select from the first tournamentSize elements
	for(int i = 0; i &lt; iTournamentSize; i++) &#123;
		int sol = indices[i];
		double fitness = oProblem.getObjectiveFunctionValue(sol);

		// don&#39;t need to be concerned about selecting randomly from multiple best
		// solutions as the tournamentSize parents were already randomised.
		if(fitness &lt; bestFitness) &#123;
			bestFitness = fitness;
			bestIndex = sol;
		&#125;
	&#125;

	return bestIndex;
&#125;
</code></pre>
<p>Replacement (TransGenerational Replacement):</p>
<pre><code class="language-java">protected int[] getNextGeneration(SAT oProblem, int iPopulationSize) &#123;

		// total population size is size of parent population plus size of offspring population
		int iTotalPopulationSize = iPopulationSize &lt;&lt; 1;

		// offspring indices are from &#39;populationSize&#39; inclusive to &#39;populationSize * 2&#39; exclusive.
		int[] aiOffspringMemoryIndices = IntStream.range(iPopulationSize, iTotalPopulationSize).toArray();

		// see if the best solution is in the current population or offspring population
		double dBestSolutionCost = Double.MAX_VALUE;
		double dWorstOffspringCost = -Double.MAX_VALUE;
		int bestIndex = -1;
		int worstOffspringIndex = -1;

		// evaluate the objective function value (cost) of each solution from both parent and offspring populations
		for(int iMemoryIndex = 0; iMemoryIndex &lt; iTotalPopulationSize; iMemoryIndex++) &#123;

			double dSolutionCost = oProblem.getObjectiveFunctionValue(iMemoryIndex);

			// update index of the best solution, favouring offspring solutions
			if( dSolutionCost &lt;= dBestSolutionCost ) &#123;
				dBestSolutionCost = dSolutionCost;
				bestIndex = iMemoryIndex;
			&#125;

			// keep track of the worst solution in the offspring population
			if( iMemoryIndex &gt;= iPopulationSize &amp;&amp; dSolutionCost &gt; dWorstOffspringCost) &#123;

				worstOffspringIndex = iMemoryIndex;
				dWorstOffspringCost = dSolutionCost;
			&#125;
		&#125;

		// if best solution is in parent population, replace worst in offspring with best from parents
		if(bestIndex &lt; iPopulationSize) &#123;

			aiOffspringMemoryIndices[worstOffspringIndex - iPopulationSize] = bestIndex;
		&#125;

		// return array of memory locations for replacement
		return aiOffspringMemoryIndices;
	&#125;
</code></pre>
<h3 id="Lab-Quiz-4"><a href="#Lab-Quiz-4" class="headerlink" title="Lab Quiz"></a>Lab Quiz</h3><p>This week lab is focusing on the genetic algorithm:</p>
<p><strong>Population Initialization</strong></p>
<ul>
<li>Generate a set of random individuals (solutions) as the initial population.</li>
</ul>
<p><strong>Fitness Evaluation</strong></p>
<ul>
<li>Compute the fitness of each individual to measure the quality of its solution.</li>
</ul>
<p><strong>Selection</strong></p>
<ul>
<li>Select individuals with higher fitness to enter the next generation (simulating natural selection).</li>
</ul>
<p><strong>Crossover</strong></p>
<ul>
<li>Choose two parent individuals to exchange genetic material and generate new offspring (simulating biological reproduction).</li>
</ul>
<p><strong>Mutation</strong></p>
<ul>
<li>Introduce small random changes in individuals with a low probability (simulating genetic mutation).</li>
</ul>
<p><strong>New Generation Formation</strong></p>
<ul>
<li>Replace the old population with the new one and repeat the iteration until the termination condition is met (e.g., reaching the maximum number of generations or convergence).</li>
</ul>
<ol>
<li><p>Q3:</p>
<p>Memetic algorithm: add local search part (hill climbing) to optimize the children.</p>
<p>ex:</p>
</li>
</ol>
<p>​	<em>A [named] statistical test was conducted to test whether the median performance of the GA and MA perform significantly different from each other. The experiments were run for a total of 31 trials with the GA using 1000 generations and the MA using 250 generations respectively resulting in a total runtime of 10 seconds each. The result of performing the [named] test shows that the MA performs significantly better than the GA with a p-value &#x3D; 0.00018 and the GA and MA obtaining median results of 81 and 24 respectively”.</em></p>
<h2 id="Week-6"><a href="#Week-6" class="headerlink" title="Week 6"></a>Week 6</h2><h3 id="Lab-Code-5"><a href="#Lab-Code-5" class="headerlink" title="Lab Code"></a>Lab Code</h3><p>Simple Inheritance:</p>
<pre><code class="language-java">public void performMemeticInheritance(int parent1Index, int parent2Index, int child1Index, int child2Index) &#123;
	double v1 = problem.getObjectiveFunctionValue(parent1Index);
	double v2 = problem.getObjectiveFunctionValue(parent2Index);
	int number = problem.getNumberOfMemes();
  
  // if same then choose parent randomly
	if (v1 == v2) &#123;
		int inheritIndex = rng.nextDouble() &lt; 0.5 ? parent1Index : parent2Index;
		for (int i = 0; i &lt; number; i++) &#123;
			problem.getMeme(child1Index, i).setMemeOption(problem.getMeme(inheritIndex, i).getMemeOption());
			problem.getMeme(child2Index, i).setMemeOption(problem.getMeme(inheritIndex, i).getMemeOption());
		&#125;
  // if &lt; choose parent 1  
	&#125; else if (v1 &lt; v2) &#123;
		for (int i = 0; i &lt; number; i++) &#123;
			problem.getMeme(child1Index, i).setMemeOption(problem.getMeme(parent1Index, i).getMemeOption());
			problem.getMeme(child2Index, i).setMemeOption(problem.getMeme(parent1Index, i).getMemeOption());
		&#125;
  // if &lt; choose parent 2  
	&#125; else &#123;
		for (int i = 0; i &lt; number; i++) &#123;
			problem.getMeme(child1Index, i).setMemeOption(problem.getMeme(parent2Index, i).getMemeOption());
			problem.getMeme(child2Index, i).setMemeOption(problem.getMeme(parent2Index, i).getMemeOption());
		&#125;
	&#125;
&#125;
</code></pre>
<p>MutiMeme:</p>
<pre><code class="language-java">public void runMainLoop() &#123;
	for(int i = 0; i &lt; POPULATION_SIZE; i+=2) &#123;
		// select two parents. we don&#39;t care if they are the same this week
		int p1 = p1selection.parentSelection();
		int p2 = p2selection.parentSelection();

		// calculate child indices
		int c1 = i + POPULATION_SIZE;
		int c2 = c1 + 1;
			
		// apply crossover
		crossover.applyHeuristic(p1, p2, c1, c2);

		// inherit memeplex using simple inheritance method
		inheritance.performMemeticInheritance(p1, p2, c1, c2);
        
        // mutation of memeplex (innovation)
		performMutationOfMemeplex(c1);
		performMutationOfMemeplex(c2);
    
		// mutation (change iom)
		applyMutationForChildDependentOnMeme(c1, 0);
		applyMutationForChildDependentOnMeme(c2, 0);

		// local search
		applyLocalSearchForChildDependentOnMeme(c1, 1, 2);
		applyLocalSearchForChildDependentOnMeme(c2, 1, 2);
	&#125;
		
	// perform replacement
	replacement.doReplacement(problem, POPULATION_SIZE);
&#125;
	
	/**
	 * Applies mutation to the child dependent on its current meme option for mutation.
	 * Mapping of meme option to IOM: IntensityOfMutation &lt;- memeOption;
	 */
public void applyMutationForChildDependentOnMeme(int childIndex, int memeIndex) &#123;
	int iom = problem.getMeme(childIndex, memeIndex).getMemeOption();
	mutation.setMutationRate(iom);
	mutation.applyHeuristic(childIndex);
&#125;
	
	/**
	 * Applies the local search operator to the child as specified by its current meme option.
	 */
public void applyLocalSearchForChildDependentOnMeme(int childIndex, int operatorMemeIndex, int depthOfSearchMemeIndex) &#123;
	int option = problem.getMeme(childIndex, operatorMemeIndex).getMemeOption();
	int depth = problem.getMeme(childIndex, depthOfSearchMemeIndex).getMemeOption();
	for (int i = 0; i &lt; depth; i++) &#123;
		lss[option].applyHeuristic(childIndex);
	&#125;
&#125;

	/**
	 * Applies mutation to each meme within the memeplex of the specified solution with probability
	 * dependent on the innovation rate.
	 */
public void performMutationOfMemeplex(int solutionIndex) &#123;
	for (int i = 0; i &lt; problem.getNumberOfMemes(); i++)&#123;
		Meme meme = problem.getMeme(solutionIndex, i);
		int initialOption = meme.getMemeOption();
		if (rng.nextDouble() &lt; innovationRate) &#123;
			int newOption = rng.nextInt(meme.getTotalOptions());
			while (newOption == initialOption)&#123;
				newOption = rng.nextInt(meme.getTotalOptions());
			&#125;
			meme.setMemeOption(newOption);
		&#125;
	&#125;
&#125;
</code></pre>
<h3 id="Lab-Quiz-5"><a href="#Lab-Quiz-5" class="headerlink" title="Lab Quiz"></a>Lab Quiz</h3><p>This week lab is focusing on the multi-meme algorithm.</p>
<p><strong>Initialization</strong></p>
<ul>
<li>Generate an initial population where each individual is assigned a <strong>memeplex</strong>.</li>
</ul>
<p><strong>Iterative Evolution (for MaxGenerations)</strong></p>
<ul>
<li><strong>Selection &amp; Crossover</strong>: Select parents (e.g., tournament selection) and perform crossover while <strong>inheriting memes</strong>.</li>
<li><strong>Innovation-Based Meme Mutation</strong>: With probability dependent on the <strong>innovation rate</strong>, modify memes in offspring.</li>
<li><strong>Genetic Mutation</strong>: Apply standard mutation to offspring, influenced by the inherited memeplex.</li>
<li><strong>Local Search</strong>: Offspring undergo local search using an operator dictated by their memeplex.</li>
<li><strong>Population Replacement</strong>: Update the population while preserving diversity.</li>
</ul>
<p><strong>Termination</strong></p>
<ul>
<li>Stop when a convergence criterion is met (e.g., best fitness stagnation, max iterations).</li>
</ul>
<ol>
<li><p>Q2:</p>
<p>No innovation for current solution, so the diversity will drop really fast.</p>
</li>
<li><p>Q3:</p>
<ul>
<li>The performance of the MMA with innovation rate &#x3D; 1.0 could be better than that with innovation rate &#x3D; 0.0 for solving MAX-SAT instance 5 because there is more chance to select a good meme option.</li>
<li>It still might generate the best meme option</li>
<li>It is impossible to inherit the same meme option</li>
<li>And of course it still have a local searching part unlike the random walk</li>
</ul>
</li>
<li><p>Q5:</p>
<p>The most beneficial here just means choose an approach under this specific circumstance.</p>
<p>And the numebr of Meme1 should be like:</p>
<table>
<thead>
<tr>
<th align="center">Approach</th>
<th align="center">allele frequencies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M_1A_0 (DBHC OI)</td>
<td align="center">9149</td>
</tr>
<tr>
<td align="center">M_1A_1 (DBHC IE)</td>
<td align="center">7752</td>
</tr>
<tr>
<td align="center">M_1A_2 (SDHC OI)</td>
<td align="center">3343</td>
</tr>
<tr>
<td align="center">M_1A_3 (SDHC IE)</td>
<td align="center">4804</td>
</tr>
</tbody></table>
<p>And you can see the frequency of the DBHC OI is the most frequent one.</p>
</li>
<li><p>Q6:</p>
<p>This one is not different as the last one, becasue this is an in general case and of course you can see that we can not decide which is the best.</p>
</li>
<li><p>Q7:</p>
<p>Unlike last question, this one just gives 2 abtract solution, so it is possible to decide which is the best and from the data, you can easily draw the conclusion.</p>
</li>
<li><p>Q8:</p>
<p>This question is focused on the search depth, you can not know that if DBHC_OI can find the best only with depth 4 data. And the answer is appearantly false.</p>
</li>
</ol>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 qp blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Zefei Xie
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>

    <script src="/js/main.js"></script>

    
    
<script
    src="https://giscus.app/client.js"
    data-repo="the-lord-of-stars/the-lord-of-stars.github.io"
    data-repo-id="R_kgDOJCquYA"
    data-category="Announcements"
    data-category-id="DIC_kwDOJCquYM4CnfcW"
    data-mapping="pathname"
    data-strict="1"
    data-reactions-enabled="0"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="en"
    crossorigin
    async
></script>





    
<!-- hexo injector body_end start --><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d = OML2D.loadOml2d({dockedPosition:"right",mobileDisplay:true,models:[{"path":"https://raw.githubusercontent.com/iCharlesZ/vscode-live2d-models/master/model-library/potion-Maker-Tia/index.json","mobilePosition":[0,0],"mobileScale":0.2,"mobileStageStyle":{"width":150,"height":125},"motionPreloadStrategy":"IDLE","position":[-25,0],"scale":0.4,"stageStyle":{"width":300,"height":250}}],parentElement:null,primaryColor:"#8ab5ff",sayHello:false,menus:false,tips:{style: {"width":230,"height":120,"left":"calc(50% - 20px)","top":"-100px"},mobileStyle: {"width":115,"height":40,"left":"calc(50% - 30px)","top":"-100px"},idleTips:{interval:15000,message:["Welcome to my website!"],wordTheDay:true},welcomeTips: {"message":{"morning":"Good morning!"}}}});</script><!-- hexo injector body_end end --></body>
</html>
